const fs = require('fs');
const path = require('path');
const bundleRunner = require('./bundle-runner');
const express = require('express');
const { renderPreloadLinks } = require('./preload-links');

const projectRoot = path.dirname(path.dirname(__filename));

const buildDir = path.join(projectRoot, 'build');
const serverBuildPath = path.join(buildDir, 'server');
const webBuildPath = path.join(buildDir, 'web');

// This is the output of build:client.
// The server will render the vue app for incoming requests and interpolate it
// into the index.html before serving out.
const indexHtmlTemplate = fs.readFileSync(path.join(webBuildPath, 'index.html'), 'utf-8');

// The SSR manifest holds mappings of vue component => assets that are in use.
// Similarly to index.html and assets, it is generated with build:client (its the --ssrManifest flag)
// As the server renders the app, it keeps track of which components it rendered.
// We use this to figure out the smallest list of assets we need to preload on the client side
// in order to hydrate it.
const ssrManifest = require(path.join(webBuildPath, 'ssr-manifest.json'));

// This is the output of build:server, and is the entry point for the ssr request.
// We read it as string instead of requiring because we only want to evaluate it within
// a new node context, and its more efficient reading it from disk once and copying it
// over to the new node context than to read it from disk for every request.
const serverBundleFile = path.join(serverBuildPath, 'server.js');
const serverVMScript = bundleRunner.getPreparedScript(serverBundleFile);

const server = express();

// Only needed in dev builds, in prod everything would be served from cdn.
server.use(
	express.static(webBuildPath, {
		// maxAge: 0,
		// fallthrough: true,
		index: false,
	})
);

server.use('/favicon.ico', (req, res) => {
	res.status(404).end();
});

// TODO: refactor this into somewhere else.

server.use(async (req, res) => {
	try {
		const context = {
			url: req.url,
			ua: req.headers['user-agent'],
			accept: req.headers['accept'] || '',
		};

		console.log(context);

		const vm = bundleRunner.getNewContext();
		// const createApp = vm.run(serverVMScript).default;

		// const app = await createApp(context);

		// console.log('created app');

		// passing SSR context object which will be available via useSSRContext()
		// @vitejs/plugin-vue injects code into a component's setup() that registers
		// itself on renderCtx.modules. After the render, renderCtx.modules would contain all the
		// components that have been instantiated during this render call.
		// vm.sandbox.app = app;
		vm.sandbox.context = context;
		vm.sandbox.serverBundleFile = serverBundleFile;
		const renderFunc = vm.run(
			`
			module.exports = async function () {
				console.log('creating app');
				const createApp = require(serverBundleFile).default;
				const app = await createApp(context);
				console.log('app created');

				const { renderToString } = require('vue/server-renderer');
				const renderCtx = {};
				const appHtml = await renderToString(app, renderCtx);
				return [appHtml, renderCtx];
			};
		`,
			path.resolve(path.join(__dirname, 'server-sandbox.js'))
		);

		const [appHtml, renderCtx] = await renderFunc();

		console.log(appHtml);

		console.log('rendered');
		console.log(renderCtx.modules);

		// the SSR manifest generated by Vite contains module -> chunk/asset mapping
		// which we can then use to determine what files need to be preloaded for this
		// request.
		const preloadLinks = renderPreloadLinks(renderCtx.modules, ssrManifest);

		const html = indexHtmlTemplate
			.replace(`<!--ssr-preload-links-->`, preloadLinks)
			.replace(`<!--ssr-outlet-->`, appHtml);

		res.status(200)
			.set({ 'Content-Type': 'text/html' })
			.end(html, () => {
				console.log('response ended');
			});
		console.log('request ending');
	} catch (e) {
		console.log(e.stack);
		res.status(500).end(e.stack);
	}
});

const port = 3501;
server.listen(port, () => {
	console.log(`server started at localhost:${port}`);
});
