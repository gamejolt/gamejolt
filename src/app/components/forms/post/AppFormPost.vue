<script lang="ts" setup>
import { addWeeks, startOfDay } from 'date-fns';
import { determine } from 'jstimezonedetect';
import { PropType, computed, nextTick, ref, toRefs, watch } from 'vue';
import { trackPostPublish } from '../../../../_common/analytics/analytics.service';
import { Api } from '../../../../_common/api/api.service';
import { BackgroundModel } from '../../../../_common/background/background.model';
import AppButton from '../../../../_common/button/AppButton.vue';
import { CommunityChannelModel } from '../../../../_common/community/channel/channel.model';
import { CommunityModel } from '../../../../_common/community/community.model';
import { ContextCapabilities } from '../../../../_common/content/content-context';
import AppExpand from '../../../../_common/expand/AppExpand.vue';
import { FiresidePostCommunityModel } from '../../../../_common/fireside/post/community/community.model';
import {
	$saveFiresidePost,
	FiresidePostAllowComments,
	FiresidePostModel,
	FiresidePostStatus,
	FiresidePostType,
} from '../../../../_common/fireside/post/post-model';
import { FiresidePostRealmModel } from '../../../../_common/fireside/post/realm/realm.model';
import { FiresidePostVideoModel } from '../../../../_common/fireside/post/video/video-model';
import AppForm, {
	FormController,
	createForm,
	defineFormProps,
} from '../../../../_common/form-vue/AppForm.vue';
import AppFormButton from '../../../../_common/form-vue/AppFormButton.vue';
import AppFormControl from '../../../../_common/form-vue/AppFormControl.vue';
import AppFormControlErrors from '../../../../_common/form-vue/AppFormControlErrors.vue';
import AppFormGroup from '../../../../_common/form-vue/AppFormGroup.vue';
import AppFormLegend from '../../../../_common/form-vue/AppFormLegend.vue';
import AppFormControlBackground from '../../../../_common/form-vue/controls/AppFormControlBackground.vue';
import AppFormControlCheckbox from '../../../../_common/form-vue/controls/AppFormControlCheckbox.vue';
import AppFormControlContent from '../../../../_common/form-vue/controls/AppFormControlContent.vue';
import AppFormControlDate from '../../../../_common/form-vue/controls/AppFormControlDate.vue';
import AppFormControlSelect from '../../../../_common/form-vue/controls/AppFormControlSelect.vue';
import AppFormControlToggle from '../../../../_common/form-vue/controls/AppFormControlToggle.vue';
import {
	validateContentMaxLength,
	validateContentNoActiveUploads,
	validateContentRequired,
	validateMaxLength,
	validateMaxValue,
	validateMinValue,
} from '../../../../_common/form-vue/validators';
import { showErrorGrowl } from '../../../../_common/growls/growls.service';
import AppJolticon from '../../../../_common/jolticon/AppJolticon.vue';
import { KeyGroupModel } from '../../../../_common/key-group/key-group.model';
import { MediaItemModel } from '../../../../_common/media-item/media-item-model';
import { storeModelList } from '../../../../_common/model/model-store.service';
import AppProgressBar from '../../../../_common/progress/AppProgressBar.vue';
import { RealmModel } from '../../../../_common/realm/realm-model';
import { Screen } from '../../../../_common/screen/screen-service';
import { SettingPostBackgroundId } from '../../../../_common/settings/settings.service';
import { useCommonStore } from '../../../../_common/store/common-store';
import AppTheme from '../../../../_common/theme/AppTheme.vue';
import { Timezone, TimezoneData } from '../../../../_common/timezone/timezone.service';
import { vAppTooltip } from '../../../../_common/tooltip/tooltip-directive';
import AppTranslate from '../../../../_common/translate/AppTranslate.vue';
import { $gettext } from '../../../../_common/translate/translate.service';
import AppUserAvatarImg from '../../../../_common/user/user-avatar/AppUserAvatarImg.vue';
import { arrayRemove } from '../../../../utils/array';
import AppContentTargets from '../../content/AppContentTargets.vue';
import { CONTENT_TARGET_HEIGHT } from '../../content/target/AppContentTarget.vue';
import AppFormPostMedia from './_media/media.vue';
import AppFormPostVideo, { VideoStatus } from './_video/video.vue';

type FormPostModel = FiresidePostModel & {
	mediaItemIds: number[];
	key_group_ids: number[];
	video_id: number;
	attached_communities: { community_id: number; channel_id: number }[];
	attached_realms: number[];
	background_id: number | null;

	// Form helper.
	_comments_enabled: boolean;

	poll_item_count: number;
	poll_duration: number;
	poll_is_private: boolean;
	poll_days: number;
	poll_hours: number;
	poll_minutes: number;
	poll_item1: string;
	poll_item2: string;
	poll_item3: string;
	poll_item4: string;
	poll_item5: string;
	poll_item6: string;
	poll_item7: string;
	poll_item8: string;
	poll_item9: string;
	poll_item10: string;
};

const MAX_POLL_ITEMS = 10;
const MIN_POLL_DURATION = 5;
const MAX_POLL_DURATION = 20160;

const props = defineProps({
	defaultCommunity: {
		type: Object as PropType<CommunityModel | null>,
		default: null,
	},
	defaultChannel: {
		type: Object as PropType<CommunityChannelModel | null>,
		default: null,
	},
	defaultRealm: {
		type: Object as PropType<RealmModel | null>,
		default: null,
	},
	overlay: {
		type: Boolean,
		default: false,
	},
	...defineFormProps<FiresidePostModel>(true),
});

const emit = defineEmits({
	submit: (_data: FiresidePostModel) => true,
	videoUploadStatusChange: (_status: VideoStatus) => true,
	backgroundChange: (_background?: BackgroundModel) => true,
});

const { defaultCommunity, defaultChannel, defaultRealm, overlay, model } = toRefs(props);

const { user } = useCommonStore();

const wasPublished = ref(false);
const attachmentType = ref<FiresidePostType.Video | FiresidePostType.Media>();
const enabledAttachments = ref(false);
const longEnabled = ref(false);
const maxFilesize = ref(0);
const maxWidth = ref(0);
const maxHeight = ref(0);
const now = ref(0);

const leadContentCapabilities = ref(ContextCapabilities.getPlaceholder());
const articleContentCapabilities = ref(ContextCapabilities.getPlaceholder());

const keyGroups = ref<KeyGroupModel[]>([]);
const timezones = ref<{ [region: string]: (TimezoneData & { label?: string })[] } | null>(null);

const maxCommunities = ref(0);
const attachedCommunities = ref<{ community: CommunityModel; channel: CommunityChannelModel }[]>(
	[]
);
const targetableCommunities = ref<CommunityModel[]>([]);

const maxRealms = ref(0);
const attachedRealms = ref<RealmModel[]>([]);

const backgrounds = ref<BackgroundModel[]>([]);

const isShowingMorePollOptions = ref(false);
const accessPermissionsEnabled = ref(false);
const isNewPost = ref(false);
const isSavedDraftPost = ref(false);
const leadLengthLimit = ref(255);
const articleLengthLimit = ref(50_000);
const isUploadingPastedImage = ref(false);
const scrollingKey = ref(1);
const uploadingVideoStatus = ref(VideoStatus.IDLE);
const isShowingMoreOptions = ref(false);

const form: FormController<FormPostModel> = createForm({
	model,
	modelClass: FiresidePostModel,
	loadUrl: computed(() => `/web/posts/manage/save/${model.value.id}`),
	onInit: async () => {
		const _model = model.value;

		isNewPost.value = _model.status === FiresidePostStatus.Temp;
		isSavedDraftPost.value = _model.status === FiresidePostStatus.Draft;

		if (isNewPost.value) {
			form.formModel.post_to_user_profile = true;
		}

		form.formModel.attached_communities = [];

		if (_model.videos.length) {
			enableVideo();
		} else if (_model.hasMedia) {
			enableImages();
		} else if (attachmentType.value) {
			enabledAttachments.value = true;
		}

		if (form.formModel.background) {
			// Assign the background_id directly instead of calling
			// [assignBackgroundId], otherwise it'll always assign `null` as we
			// haven't loaded our eligible backgrounds yet.
			form.formModel.background_id = form.formModel.background.id;
		}

		if (_model.poll) {
			const poll = _model.poll;

			let duration = poll.duration / 60; // We want to work in minutes.
			form.formModel.poll_duration = duration;

			form.formModel.poll_days = Math.floor(duration / 1440);
			duration -= form.formModel.poll_days * 1440;
			form.formModel.poll_hours = Math.floor(duration / 60);
			duration -= form.formModel.poll_hours * 60;
			form.formModel.poll_minutes = duration;

			form.formModel.poll_is_private = poll.is_private;

			form.formModel.poll_item_count = poll.items.length;
			for (let i = 0; i < poll.items.length; i++) {
				(form.formModel[('poll_item' + (i + 1)) as keyof typeof form.formModel] as any) =
					poll.items[i].text;
			}
		}

		if (_model.key_groups.length) {
			accessPermissionsEnabled.value = true;
		}

		if (_model.has_article) {
			longEnabled.value = true;
			// Initialize this so ContentEditor doesn't complain while loading in.
			form.formModel.article_content = '';
		}

		form.formModel._comments_enabled =
			_model.allow_comments === FiresidePostAllowComments.Disabled ? false : true;

		// Auto-show the more options if the comment options are anything other
		// than the default.
		isShowingMoreOptions.value =
			form.formModel.allow_comments !== FiresidePostAllowComments.Enabled;

		await fetchTimezones();
	},
	onLoad(payload) {
		// Pull any post information that may not already be loaded in.
		form.formModel.article_content = payload.post.article_content;

		leadContentCapabilities.value = ContextCapabilities.fromPayloadList(
			payload.leadContentCapabilities
		);

		articleContentCapabilities.value = ContextCapabilities.fromPayloadList(
			payload.articleContentCapabilities
		);

		keyGroups.value = KeyGroupModel.populate(payload.keyGroups);
		wasPublished.value = payload.wasPublished;
		maxFilesize.value = payload.maxFilesize;
		maxWidth.value = payload.maxWidth;
		maxHeight.value = payload.maxHeight;
		leadLengthLimit.value = payload.leadLengthLimit;
		articleLengthLimit.value = payload.articleLengthLimit;
		maxCommunities.value = payload.maxCommunities;
		maxRealms.value = payload.maxRealms;

		backgrounds.value = storeModelList(BackgroundModel, payload.backgrounds);

		// Use our saved background id if we're not editing.
		if (!isEditing.value) {
			assignBackgroundId(_getMatchingBackgroundIdFromPref());
		}

		if (payload.attachedCommunities) {
			attachedCommunities.value = FiresidePostCommunityModel.populate(
				payload.attachedCommunities
			).map((fpc: FiresidePostCommunityModel) => {
				return {
					community: fpc.community,
					channel: fpc.channel!,
				};
			});
		}

		if (payload.attachedRealms) {
			attachedRealms.value = FiresidePostRealmModel.populate(payload.attachedRealms).map(
				i => i.realm
			);
		}

		if (defaultRealm.value) {
			attachRealm(defaultRealm.value);
		}

		if (
			defaultCommunity.value &&
			defaultChannel.value &&
			defaultCommunity.value.postableChannels.some(
				channel => channel.title === defaultChannel.value!.title
			)
		) {
			attachCommunity(defaultCommunity.value, defaultChannel.value);
		}

		if (payload.targetableCommunities) {
			targetableCommunities.value = CommunityModel.populate(payload.targetableCommunities);

			// Filter out communities the user is blocked from,
			// and communities who don't have channels the current user can post to.
			targetableCommunities.value = targetableCommunities.value.filter(
				community => !community.isBlocked && community.postableChannels.length > 0
			);
		}
	},

	onSubmitError(payload: any) {
		if (payload.errors.video_unavailable) {
			showErrorGrowl({
				title: $gettext(`Failed to submit post`),
				message: $gettext(
					`The video linked in the post is private or otherwise unavailable. Make sure other people can see the video before you post it.`
				),
			});
		}
	},
	onSubmit() {
		// a scheduled post gets saved as draft and will get set to published when the scheduled date is reached
		if (isScheduling.value) {
			form.formModel.status = FiresidePostStatus.Draft;
		}

		form.formModel.attached_communities = attachedCommunities.value.map(
			({ community, channel }) => ({
				community_id: community.id,
				channel_id: channel.id,
			})
		);

		form.formModel.attached_realms = attachedRealms.value.map(i => i.id);

		// Set or clear attachments as needed
		if (attachmentType.value === FiresidePostType.Media && form.formModel.media) {
			form.formModel.mediaItemIds = form.formModel.media.map(item => item.id);
		} else {
			form.formModel.mediaItemIds = [];
		}

		if (attachmentType.value === FiresidePostType.Video) {
			// Unset the video url for linked videos and set the video id for uploaded videos
			// to signal to the backend that the attached video should be kept.
			form.formModel.video_id = form.formModel.videos[0].id;
		} else {
			form.formModel.video_id = 0;
		}

		if (!accessPermissionsEnabled.value) {
			form.formModel.key_group_ids = [];
		}

		if (!longEnabled.value) {
			form.formModel.article_content = '';
		}

		form.formModel.poll_duration = pollDuration.value * 60; // site-api expects duration in seconds.

		return $saveFiresidePost(form.formModel);
	},
	onSubmitSuccess() {
		Object.assign(model.value, form.formModel);
		emit('submit', model.value);
	},
});

const mainActionText = computed(() => {
	if (wasPublished.value) {
		return $gettext('Save');
	} else if (isScheduling.value) {
		return $gettext('Schedule');
	} else if (isSavedDraftPost.value) {
		return $gettext('Publish');
	} else {
		return $gettext('Post');
	}
});

const isEditing = computed(() => wasPublished.value || isSavedDraftPost.value);

const enabledImages = computed(
	() => enabledAttachments.value && attachmentType.value === FiresidePostType.Media
);

const enabledVideo = computed(
	() => enabledAttachments.value && attachmentType.value === FiresidePostType.Video
);

const hasPoll = computed(() => {
	return form.formModel.poll_item_count > 0;
});

const isPollEditable = computed(() => {
	const poll = model.value.poll;
	if (poll) {
		return !poll.end_time;
	}
	return true;
});

const pollDuration = computed(() => {
	return (
		form.formModel.poll_days * 1440 +
		form.formModel.poll_hours * 60 +
		form.formModel.poll_minutes * 1 // cast to int lol
	);
});

const isPollTooShort = computed(() => hasPoll.value && pollDuration.value < MIN_POLL_DURATION);

const isPollTooLong = computed(() => hasPoll.value && pollDuration.value > MAX_POLL_DURATION);

const scheduledTimezoneOffset = computed(() => {
	if (!form.formModel.scheduled_for_timezone) {
		return 0;
	}

	const tz = timezoneByName(form.formModel.scheduled_for_timezone);
	if (!tz) {
		console.warn('Could not find timezone offset for: ' + tz);
		return 0;
	} else {
		return tz.o * 1000;
	}
});

const isScheduling = computed(() => form.formModel.isScheduled);

const leadLengthPercent = computed(
	() => 100 - (form.formModel.leadLength / leadLengthLimit.value) * 100
);

const canAddCommunity = computed(
	() =>
		!wasPublished.value &&
		attachedCommunities.value.length < maxCommunities.value &&
		possibleCommunities.value.length > 0
);

const canAddRealm = computed(() => attachedRealms.value.length < maxRealms.value);

const hasChannelError = computed(() => form.hasCustomError('channel'));

const possibleCommunities = computed(() => {
	// Difference between targetable and attached communities.
	return targetableCommunities.value.filter(c1 => {
		// Also exclude the default community. If it is specified,
		// it'll be force-added through the pill-incomplete component.
		if (c1.id === defaultCommunity?.value?.id) {
			return false;
		}

		return !attachedCommunities.value.find(c2 => c1.id === c2.community.id);
	});
});

const incompleteDefaultCommunity = computed(() => {
	// The default community is considered incomplete if the channel for it
	// needs to be selected (default channel is null or the community is not attached to the post).

	const community = defaultCommunity.value;

	if (!(community instanceof CommunityModel)) {
		return null;
	}

	const matchingAttachedCommunity = attachedCommunities.value.find(
		i => i.community.id === community.id
	);

	if (matchingAttachedCommunity) {
		return null;
	}

	return community;
});

const submitButtonsEnabled = computed(
	() =>
		form.valid &&
		uploadingVideoStatus.value !== VideoStatus.UPLOADING &&
		!isPollTooShort.value &&
		!isPollTooLong.value
);

const shouldShowAuthorOptions = computed(() => {
	if (!model.value.game || !user.value) {
		return false;
	}

	// Original post authors can always choose whether to share the post on their profile.
	if (user.value.id === model.value.user.id) {
		return true;
	}

	// Otherwise it means we're the resource owner the post was posted on.
	// We can't toggle on sharing the post to profile because its not our post.
	// We can only toggle "as game owner" if the post isn't already shared
	// on the author's profile.
	return !model.value.post_to_user_profile;
});

watch(
	() => form.formModel.post_to_user_profile,
	() => {
		if (form.formModel.post_to_user_profile) {
			form.formModel.as_game_owner = false;
		}
	}
);

watch(
	() => form.formModel.as_game_owner,
	() => {
		if (form.formModel.as_game_owner) {
			form.formModel.post_to_user_profile = false;
		}
	}
);

watch(incompleteDefaultCommunity, () => {
	if (incompleteDefaultCommunity.value) {
		form.setCustomError('channel');
	} else {
		form.clearCustomError('channel');
	}
});

// When toggling the "Comments enabled?" checkbox back and forth.
watch(
	() => form.formModel._comments_enabled,
	enabled => {
		// Gotta wait for form to be initialized before we start listening to
		// changes.
		if (!form.isLoaded) {
			return;
		}

		if (enabled) {
			form.formModel.allow_comments = FiresidePostAllowComments.Enabled;
		} else {
			form.formModel.allow_comments = FiresidePostAllowComments.Disabled;
		}
	}
);

function attachIncompleteCommunity(community: CommunityModel, channel?: CommunityChannelModel) {
	if (!channel) {
		console.warn('Attempt to attach a community without a channel');
		return;
	}

	attachCommunity(community, channel, false);
}

function attachCommunity(
	community: CommunityModel,
	channel?: CommunityChannelModel,
	append = true
) {
	if (!channel) {
		console.warn('Attempt to attach a community without a channel');
		return;
	}

	// Do nothing if that community is already attached.
	if (attachedCommunities.value.find(i => i.community.id === community.id)) {
		return;
	}

	if (append) {
		attachedCommunities.value.push({ community, channel });
		scrollToAdd();
	} else {
		attachedCommunities.value.unshift({ community, channel });
	}
}

function attachRealm(realm: RealmModel, append = true) {
	// Do nothing if that realm is already attached.
	if (attachedRealms.value.find(i => i.id === realm.id)) {
		return;
	}

	if (append) {
		attachedRealms.value.push(realm);
		scrollToAdd();
	} else {
		attachedRealms.value.unshift(realm);
	}
}

async function scrollToAdd() {
	// Wait for the DOM to update
	await nextTick();
	// Change our scrolling key so AppScrollWhen will bring the 'Add Community'
	// button inview.
	scrollingKey.value *= -1;
}

function removeCommunity(community: CommunityModel) {
	arrayRemove(attachedCommunities.value, i => i.community.id === community.id, {
		onMissing: () => console.warn('Attempted to remove a community that is not attached'),
	});
}

function removeRealm(realm: RealmModel) {
	arrayRemove(attachedRealms.value, i => i.id === realm.id, {
		onMissing: () => console.warn('Attempted to remove a realm that is not attached'),
	});
}

function onDraftSubmit() {
	form.formModel.status = FiresidePostStatus.Draft;
}

function onPublishSubmit() {
	form.formModel.status = FiresidePostStatus.Active;
	trackPostPublish();
}

function enableImages() {
	enabledAttachments.value = true;
	attachmentType.value = FiresidePostType.Media;
}

function onMediaUploaded(mediaItems: MediaItemModel[]) {
	const newMedia = mediaItems.concat(form.formModel.media);
	form.formModel.media = newMedia;
}

function onMediaUploadFailed(reason: string) {
	let message = $gettext(
		'Something went wrong while we tried uploading your media. Maybe try again?'
	);
	switch (reason) {
		case 'no-dimensions':
			message = $gettext('We failed to analyze your media.');
			break;
		case 'no-image-video':
			message = $gettext(
				'Looks like the file you uploaded is not an image or video we recognize.'
			);
			break;
		case 'no-extension':
			message = $gettext('We could not determine the file type of your media.');
			break;
		case 'invalid-mime-type':
			message = $gettext(
				'We currently do not support the format of your uploaded media. Try exporting it to a different format.'
			);
			break;
	}

	showErrorGrowl(message, $gettext('Failed to upload your media.'));
}

function onMediaSort(mediaItems: MediaItemModel[]) {
	form.formModel.media = mediaItems;
}

function removeMediaItem(mediaItem: MediaItemModel) {
	const newMedia = form.formModel.media.filter(item => item.id !== mediaItem.id);
	form.formModel.media = newMedia;
}

function enableVideo() {
	enabledAttachments.value = true;
	attachmentType.value = FiresidePostType.Video;
}

function disableAttachments() {
	enabledAttachments.value = false;
	attachmentType.value = undefined;

	form.formModel.media = [];
	form.formModel.videos = [];
}

function toggleLong() {
	longEnabled.value = !longEnabled.value;
}

function createPoll() {
	// Initialize default poll
	form.formModel.poll_days = 1;
	form.formModel.poll_hours = 0;
	form.formModel.poll_minutes = 0;
	form.formModel.poll_item_count = 2;
	for (let i = 0; i < MAX_POLL_ITEMS; i++) {
		(form.formModel[('poll_item' + (i + 1)) as keyof typeof form.formModel] as any) = '';
	}

	form.changed = true;
}

function removePoll() {
	form.formModel.poll_item_count = 0;
	form.changed = true;
}

function removePollItem(idx: number) {
	if (form.formModel.poll_item_count <= 2) {
		return;
	}

	for (let i = idx; i < form.formModel.poll_item_count; i++) {
		(form.formModel[('poll_item' + i) as keyof typeof form.formModel] as any) = (
			form.formModel as any
		)['poll_item' + (i + 1)];
	}

	form.formModel.poll_item_count = form.formModel.poll_item_count - 1;
	form.changed = true;
}

function addPollItem() {
	if (form.formModel.poll_item_count >= MAX_POLL_ITEMS) {
		return;
	}

	(form.formModel[
		('poll_item' + (form.formModel.poll_item_count + 1)) as keyof typeof form.formModel
	] as any) = '';
	form.formModel.poll_item_count = form.formModel.poll_item_count + 1;
	form.changed = true;
}

function enableAccessPermissions() {
	accessPermissionsEnabled.value = true;
}

function disableAccessPermissions() {
	accessPermissionsEnabled.value = false;
}

function addSchedule() {
	if (form.formModel.scheduled_for === null) {
		form.formModel.scheduled_for = startOfDay(addWeeks(Date.now(), 1)).getTime();
	}

	now.value = Date.now();
	form.formModel.scheduled_for_timezone = determine().name();
	form.changed = true;
}

function removeSchedule() {
	form.formModel.scheduled_for_timezone = null;
	form.formModel.scheduled_for = null;
	form.changed = true;
}

function timezoneByName(timezone: string) {
	for (const region in timezones.value) {
		const tz = timezones.value[region].find(_tz => _tz.i === timezone);
		if (tz) {
			return tz;
		}
	}
	return null;
}

async function fetchTimezones() {
	// Get timezones list.
	timezones.value = await Timezone.getGroupedTimezones();
	for (const region in timezones.value) {
		for (const tz of timezones.value[region]) {
			let offset = '';
			if (tz.o > 0) {
				offset = `+${tz.o / 3600}:00`;
			} else if (tz.o < 0) {
				offset = `-${-tz.o / 3600}:00`;
			}
			tz.label = `(UTC${offset}) ${tz.i}`;
		}
	}
}

async function onPaste(e: ClipboardEvent) {
	// Do not react to paste events when "Images" is not selected.
	if (!!attachmentType.value && attachmentType.value !== FiresidePostType.Media) {
		return;
	}
	if (isUploadingPastedImage.value) {
		return;
	}

	// Validate clipboard data
	if (!e.clipboardData) {
		return;
	}

	const items = e.clipboardData.items;
	if (!items) {
		return;
	}

	const files = [];

	for (let i = 0; i < items.length; i++) {
		const item = items[i];
		if (item.type.includes('image')) {
			const blob = item.getAsFile();
			if (blob) {
				files.push(blob);
			}
		}
	}

	if (files.length === 0) {
		return;
	}

	// Show image tray.
	if (!enabledImages.value) {
		enableImages();
	}

	// Upload
	isUploadingPastedImage.value = true;

	const $payload = await Api.sendRequest(
		`/web/posts/manage/add-media/${form.formModel.id}`,
		{},
		{
			file: files,
			progress: e2 => (form.formModel._progress = e2),
			noErrorRedirect: true,
		}
	);

	isUploadingPastedImage.value = false;

	if ($payload.success) {
		// Apply returned media items.
		const mediaItems = MediaItemModel.populate($payload.mediaItems);
		onMediaUploaded(mediaItems);
	} else {
		onMediaUploadFailed($payload.reason);
	}
}

function onVideoChanged(video: FiresidePostVideoModel | null) {
	if (video === null) {
		form.formModel.videos = [];
	} else {
		form.formModel.videos = [video];
	}
}

function onUploadingVideoStatusChanged(status: VideoStatus) {
	uploadingVideoStatus.value = status;
	emit('videoUploadStatusChange', uploadingVideoStatus.value);
}

function onDisableVideoAttachment() {
	disableAttachments();
}

function assignBackgroundId(backgroundId: number | null) {
	const background = backgroundId
		? backgrounds.value.find(i => i.id === backgroundId)
		: undefined;

	form.formModel.background_id = background?.id || null;
	emit('backgroundChange', background);
}

function onBackgroundChanged(backgroundId: number | null) {
	assignBackgroundId(backgroundId);
	SettingPostBackgroundId.set(backgroundId ?? -1);
}

function _getMatchingBackgroundIdFromPref() {
	if (backgrounds.value.length === 0) {
		return null;
	}

	const prefId = SettingPostBackgroundId.get();
	if (prefId === -1) {
		return null;
	}

	// Use the saved ID only if we have an eligible background.
	return backgrounds.value.find(i => i.id == prefId)?.id || null;
}
</script>

<template>
	<AppForm v-if="model" :controller="form">
		<!-- Attachments -->
		<div v-if="!enabledAttachments" class="-attachment-controls">
			<AppButton
				trans
				:primary="enabledImages"
				:solid="enabledImages"
				:overlay="overlay"
				icon="screenshot"
				@click="enableImages()"
			>
				<AppTranslate>Images/GIFs</AppTranslate>
			</AppButton>

			<AppButton
				trans
				:primary="enabledVideo"
				:solid="enabledVideo"
				:overlay="overlay"
				icon="video"
				@click="enableVideo()"
			>
				<AppTranslate>Video</AppTranslate>
			</AppButton>
		</div>
		<div v-else class="well fill-offset full-bleed">
			<!-- Images -->
			<fieldset v-if="enabledImages">
				<AppFormLegend compact deletable @delete="disableAttachments()">
					<AppTranslate>Select images</AppTranslate>
				</AppFormLegend>

				<AppFormPostMedia
					:media-items="form.formModel.media"
					:post="form.formModel"
					:max-filesize="maxFilesize"
					:max-width="maxWidth"
					:max-height="maxHeight"
					:loading="isUploadingPastedImage"
					@upload="onMediaUploaded($event)"
					@error="onMediaUploadFailed($event)"
					@remove="removeMediaItem($event)"
					@sort="onMediaSort($event)"
				/>
			</fieldset>

			<!-- Video -->
			<AppFormPostVideo
				v-else-if="enabledVideo"
				:post="form.formModel"
				:was-published="wasPublished"
				@delete="onDisableVideoAttachment"
				@video-change="onVideoChanged"
				@video-status-change="onUploadingVideoStatusChanged"
			/>
		</div>

		<!-- Post title (short) -->
		<AppFormGroup
			name="lead_content"
			class="-lead-form-group"
			:label="!longEnabled ? $gettext(`Post`) : $gettext(`Summary`)"
			hide-label
		>
			<AppFormControlContent
				content-context="fireside-post-lead"
				:capabilities="leadContentCapabilities"
				autofocus
				:placeholder="
					!longEnabled
						? $gettext(`What's new?`)
						: $gettext(`Write a summary for your article...`)
				"
				:model-data="{
					type: 'resource',
					resource: 'Fireside_Post',
					resourceId: model.id,
				}"
				:model-id="model.id"
				:min-height="72"
				:validators="[validateContentRequired(), validateContentMaxLength(leadLengthLimit)]"
				@paste="onPaste"
			/>

			<AppTheme :force-dark="overlay">
				<div class="-hp" :class="{ '-overlay-text': overlay }">
					<div class="-hp-label" :class="{ '-overlay': overlay }">HP</div>
					<div class="-hp-bar">
						<AppProgressBar
							thin
							:percent="leadLengthPercent"
							:animate="false"
							:class="{ '-overlay-box': overlay }"
						/>
					</div>
					<div v-if="leadLengthPercent <= 10" class="-hp-count">
						{{ leadLengthLimit - form.formModel.leadLength }}
					</div>
				</div>

				<AppFormGroup
					v-if="backgrounds.length > 0"
					name="background_id"
					class="-backgrounds"
					hide-label
					optional
					:label="$gettext(`Background`)"
				>
					<AppFormControlBackground
						:backgrounds="backgrounds"
						:tile-size="40"
						@changed="onBackgroundChanged"
					/>
				</AppFormGroup>
			</AppTheme>

			<AppFormControlErrors />
		</AppFormGroup>

		<!-- Post body (long) -->
		<div v-if="longEnabled" class="well fill-offset full-bleed">
			<fieldset>
				<AppFormLegend compact deletable @delete="toggleLong()">
					<AppTranslate>Article content</AppTranslate>
				</AppFormLegend>

				<AppFormGroup
					name="article_content"
					:label="$gettext(`Article Content`)"
					hide-label
					optional
				>
					<AppFormControlContent
						:placeholder="$gettext(`Write your article here...`)"
						content-context="fireside-post-article"
						:capabilities="articleContentCapabilities"
						:model-data="{
							type: 'resource',
							resource: 'Fireside_Post',
							resourceId: model.id,
						}"
						:model-id="model.id"
						:validators="[
							validateContentNoActiveUploads(),
							validateContentMaxLength(articleLengthLimit),
						]"
						:max-height="0"
					/>

					<AppFormControlErrors />
				</AppFormGroup>
			</fieldset>
		</div>

		<!-- Poll -->
		<div v-if="hasPoll" class="well fill-offset full-bleed">
			<fieldset>
				<AppFormLegend compact :deletable="isPollEditable" @delete="removePoll()">
					<AppTranslate>Set up poll</AppTranslate>
				</AppFormLegend>

				<!-- i starts from 1 -->
				<div v-for="i of form.formModel.poll_item_count" :key="i" class="-poll-option">
					<AppFormGroup :name="'poll_item' + i" :label="$gettext(`choice`)" hide-label>
						<AppFormControl
							type="text"
							:validators="[validateMaxLength(64)]"
							:placeholder="$gettext('Choice %{ num }', { num: i })"
							:disabled="!isPollEditable"
						/>

						<AppFormControlErrors />
					</AppFormGroup>

					<!-- Can't have less than 2 poll items -->
					<a
						v-if="form.formModel.poll_item_count > 2 && isPollEditable"
						class="-poll-option-remove link-muted"
						@click="removePollItem(i)"
					>
						<AppJolticon icon="remove" />
					</a>
				</div>

				<div>
					<a
						v-if="isPollEditable && form.formModel.poll_item_count < MAX_POLL_ITEMS"
						@click="addPollItem()"
					>
						+
						<AppTranslate>Add choice</AppTranslate>
					</a>
				</div>
			</fieldset>

			<br />

			<fieldset class="-poll-duration">
				<AppFormLegend compact>
					<AppTranslate>Duration</AppTranslate>
				</AppFormLegend>

				<div class="row">
					<div class="col-xs-4">
						<AppFormGroup name="poll_days" :label="$gettext('Days')" optional>
							<AppFormControl
								type="number"
								step="1"
								min="0"
								max="14"
								:disabled="!isPollEditable"
								:validators="[validateMinValue(0), validateMaxValue(14)]"
							/>
						</AppFormGroup>
					</div>

					<div class="col-xs-4">
						<AppFormGroup name="poll_hours" :label="$gettext('Hours')" optional>
							<AppFormControl
								type="number"
								step="1"
								min="0"
								max="23"
								:disabled="!isPollEditable"
								:validators="[validateMinValue(0), validateMaxValue(23)]"
							/>
						</AppFormGroup>
					</div>

					<div class="col-xs-4">
						<AppFormGroup name="poll_minutes" :label="$gettext('Minutes')" optional>
							<AppFormControl
								type="number"
								step="1"
								min="0"
								max="59"
								:disabled="!isPollEditable"
								:validators="[validateMinValue(0), validateMaxValue(59)]"
							/>
						</AppFormGroup>
					</div>
				</div>

				<p v-if="isPollTooShort" class="help-block error">
					<AppTranslate>
						Too short! Polls must be between 5 minutes and 14 days long.
					</AppTranslate>
				</p>
				<p v-else-if="isPollTooLong" class="help-block error">
					<AppTranslate>
						Too long! Polls must be between 5 minutes and 14 days long.
					</AppTranslate>
				</p>
				<br v-else />
			</fieldset>

			<fieldset>
				<AppFormLegend
					compact
					expandable
					:expanded="isShowingMorePollOptions"
					@click="isShowingMorePollOptions = !isShowingMorePollOptions"
				>
					<AppTranslate>More options</AppTranslate>
				</AppFormLegend>

				<div v-show="isShowingMorePollOptions">
					<AppFormGroup name="poll_is_private" :label="$gettext(`Private results?`)">
						<template #inline-control>
							<AppFormControlToggle />
						</template>

						<p class="help-block sans-margin-top">
							<AppTranslate>
								The poll's results will be kept hidden if this is turned on.
							</AppTranslate>
						</p>
					</AppFormGroup>
				</div>
			</fieldset>
		</div>

		<!-- Scheduling -->
		<div v-if="!wasPublished && isScheduling && timezones" class="well fill-offset full-bleed">
			<fieldset>
				<AppFormLegend compact deletable @delete="removeSchedule()">
					<AppTranslate>Schedule publishing of post</AppTranslate>
				</AppFormLegend>

				<AppFormGroup name="scheduled_for_timezone" :label="$gettext(`Timezone`)">
					<p class="help-block">
						<AppTranslate>
							All time selection below will use this timezone.
						</AppTranslate>
					</p>

					<p class="help-block">
						<strong>
							<AppTranslate>
								Should auto-detect, but if it doesn't, choose your closest city.
							</AppTranslate>
						</strong>
					</p>

					<AppFormControlSelect>
						<optgroup
							v-for="(item, region) of timezones"
							:key="region"
							:label="`${region}`"
						>
							<option v-for="timezone of item" :key="timezone.i" :value="timezone.i">
								{{ timezone.label }}
							</option>
						</optgroup>
					</AppFormControlSelect>

					<AppFormControlErrors />
				</AppFormGroup>

				<AppFormGroup name="scheduled_for" :label="$gettext(`Date and time`)">
					<AppFormControlDate
						:timezone-offset="scheduledTimezoneOffset"
						:min-date="now"
					/>
					<AppFormControlErrors :label="$gettext(`scheduled for`)" />
				</AppFormGroup>
			</fieldset>
		</div>

		<!-- Access permissions -->
		<template v-if="accessPermissionsEnabled">
			<div v-if="!wasPublished" class="well fill-offset full-bleed">
				<fieldset>
					<AppFormLegend compact deletable @delete="disableAccessPermissions()">
						<AppTranslate>Access permissions</AppTranslate>
					</AppFormLegend>

					<AppFormGroup
						name="key_group_ids"
						:label="$gettext(`Access Permissions`)"
						hide-label
					>
						<div v-if="!keyGroups.length" class="alert">
							<AppTranslate>
								You can make this post available to only the users within a key
								group. For example, this is useful for sending news updates to
								testers. You can create a user key group through the "Keys/Access"
								page.
							</AppTranslate>
						</div>
						<div v-else>
							<p class="help-block">
								<AppTranslate>
									You can make this post available to only the users within a key
									group. For example, this is useful for sending news updates to
									testers. Only User-type key groups can be selected.
								</AppTranslate>
							</p>

							<div v-for="keyGroup of keyGroups" :key="keyGroup.id" class="checkbox">
								<label>
									<AppFormControlCheckbox :value="keyGroup.id" />
									{{ keyGroup.name }}
								</label>
							</div>
						</div>
					</AppFormGroup>
				</fieldset>
			</div>
			<div v-else class="form-group well fill-offset full-bleed">
				<label class="control-label">
					<AppTranslate>Access Permissions</AppTranslate>
				</label>
				<div class="alert">
					<AppTranslate>
						The below key groups have access to this post. You can't edit who has access
						after posting since notifications have already gone out.
					</AppTranslate>
				</div>
				<div>
					<span v-for="keyGroup of model.key_groups" :key="keyGroup.id" class="tag">
						{{ keyGroup.name }}
					</span>
				</div>
			</div>
		</template>

		<!-- Other platforms -->
		<div v-if="isShowingMoreOptions" class="well fill-offset full-bleed">
			<fieldset>
				<AppFormLegend compact>
					<AppTranslate>More options</AppTranslate>
				</AppFormLegend>

				<AppFormGroup
					name="_comments_enabled"
					:label="$gettext(`Enable comments?`)"
					style="margin-bottom: 0"
				>
					<template #inline-control>
						<AppFormControlToggle />
					</template>
				</AppFormGroup>

				<AppFormGroup
					v-if="form.formModel._comments_enabled"
					name="allow_comments"
					:label="$gettext(`Who can comment?`)"
				>
					<AppFormControlSelect>
						<option :value="FiresidePostAllowComments.Enabled">
							{{ $gettext(`Everyone`) }}
						</option>
						<option :value="FiresidePostAllowComments.Friends">
							{{ $gettext(`Only friends`) }}
						</option>
					</AppFormControlSelect>
				</AppFormGroup>
			</fieldset>
		</div>

		<!-- Communities/Realms -->
		<template v-if="form.isLoaded">
			<AppContentTargets
				class="-content-targets"
				:communities="attachedCommunities"
				:realms="attachedRealms"
				:targetable-communities="possibleCommunities"
				:can-add-community="canAddCommunity"
				:can-add-realm="canAddRealm"
				:max-communities="maxCommunities"
				:max-realms="maxRealms"
				:incomplete-community="incompleteDefaultCommunity || undefined"
				:can-remove-communities="!wasPublished"
				can-remove-realms
				@remove-community="removeCommunity"
				@remove-realm="removeRealm"
				@select-community="attachCommunity"
				@select-incomplete-community="attachIncompleteCommunity"
				@select-realm="attachRealm"
			/>
		</template>
		<template v-else>
			<div class="-content-targets-placeholder">
				<div
					class="-content-target-placeholder"
					:style="{ height: CONTENT_TARGET_HEIGHT + 'px' }"
				/>
			</div>
		</template>

		<div v-if="!wasPublished" class="-error-no-channel">
			<div class="-caret" :class="{ '-hide': !hasChannelError }" />
			<AppExpand :when="hasChannelError">
				<div class="-error -earmark alert alert-notice">
					<AppTranslate>Choose a channel to post to.</AppTranslate>
				</div>
			</AppExpand>
		</div>

		<!-- Author options -->
		<AppTheme
			v-if="shouldShowAuthorOptions"
			:class="{ '-overlay-text': overlay }"
			:force-dark="overlay"
		>
			<fieldset>
				<!-- Post to profile -->
				<AppFormGroup
					v-if="user && user.id == model.user.id"
					name="post_to_user_profile"
					class="sans-margin-bottom"
					:label="$gettext(`Post to Profile`)"
				>
					<template #inline-control>
						<AppFormControlToggle />
					</template>

					<p class="help-block sans-margin-top" :class="{ '-text-white': overlay }">
						This will post to your profile as well as the game page.
					</p>
				</AppFormGroup>

				<!-- Post as game owner -->
				<AppFormGroup
					v-if="model.game && model.user.id != model.game.developer.id"
					name="as_game_owner"
					:label="$gettext(`Post as Game Owner`)"
				>
					<template #inline-control>
						<AppFormControlToggle />
					</template>

					<div
						v-if="form.formModel.as_game_owner"
						v-app-tooltip.touchable="
							model.game.developer.display_name +
							` (@${model.game.developer.username})`
						"
						class="-author-avatar pull-right"
					>
						<AppUserAvatarImg :user="model.game.developer" />
					</div>
					<p class="help-block sans-margin-top" :class="{ '-text-white': overlay }">
						<AppTranslate
							:translate-params="{
								owner: `@${model.game.developer.username}`,
								author: `@${model.user.username}`,
							}"
						>
							This will show %{ owner } as the user that posted.
						</AppTranslate>
					</p>
				</AppFormGroup>
			</fieldset>
		</AppTheme>

		<!-- Controls -->
		<div class="-controls">
			<div class="-controls-attachments" :class="{ '-overlay-text': overlay }">
				<AppButton
					v-if="!longEnabled"
					v-app-tooltip="$gettext(`Add article`)"
					sparse
					trans
					circle
					icon="blog-article"
					@click="toggleLong()"
				/>

				<AppButton
					v-if="!hasPoll"
					v-app-tooltip="$gettext(`Add poll`)"
					sparse
					trans
					circle
					icon="pedestals-numbers"
					@click="createPoll()"
				/>

				<AppButton
					v-if="!wasPublished && !isScheduling"
					v-app-tooltip="$gettext(`Schedule post`)"
					sparse
					trans
					circle
					icon="calendar-grid"
					@click="addSchedule()"
				/>

				<AppButton
					v-if="!accessPermissionsEnabled && !wasPublished && model.game"
					v-app-tooltip="$gettext(`Permissions`)"
					sparse
					trans
					circle
					icon="key-diagonal"
					@click="enableAccessPermissions()"
				/>

				<AppButton
					v-if="!isShowingMoreOptions"
					v-app-tooltip="$gettext(`More options`)"
					sparse
					trans
					circle
					icon="ellipsis-h"
					@click="isShowingMoreOptions = true"
				/>
			</div>

			<AppTheme :force-dark="overlay" class="-controls-submit">
				<div class="-controls-submit-button">
					<AppFormButton
						v-if="!wasPublished && !isScheduling"
						:disabled="!submitButtonsEnabled"
						:solid="false"
						:primary="false"
						trans
						:block="Screen.isXs"
						:overlay="overlay"
						@before-submit="onDraftSubmit()"
					>
						<AppTranslate>Save Draft</AppTranslate>
					</AppFormButton>
				</div>
				{{ ' ' }}
				<div class="-controls-submit-button">
					<AppFormButton
						:disabled="!submitButtonsEnabled"
						primary
						solid
						:block="Screen.isXs"
						:overlay="overlay"
						@before-submit="onPublishSubmit()"
					>
						{{ mainActionText }}
					</AppFormButton>
				</div>
			</AppTheme>
		</div>
	</AppForm>
</template>

<style lang="stylus" scoped>
.form-group:last-child
	margin-bottom: 10px

.-attachment-controls
	margin-bottom: $line-height-computed

	@media $media-xs
		white-space: nowrap
		overflow-x: scroll
		overflow-y: hidden

.-upload-input
	display: none

.-lead-form-group
	margin-bottom: 10px

.-hp
	display: flex
	align-items: center
	margin-top: 5px

.-hp-label
	theme-prop('color', 'fg-muted')
	flex: none
	margin-right: 10px
	font-size: $font-size-small
	font-weight: bold

	&.-overlay
		theme-prop('color', 'fg')

.-hp-bar
	flex: auto

	.progress
		margin-bottom: 0

.-hp-count
	theme-prop('color', 'notice')
	flex: none
	margin-left: 10px
	font-size: $font-size-small
	font-weight: bold

.-backgrounds
	margin-top: 8px
	margin-bottom: 16px

.-channels
	margin-top: 10px

.-channels
.-error
.-community-message
	margin-bottom: 10px

.-error-no-channel
	position: relative

	.alert
		padding: 10px !important

	.-caret
		caret(color: var(--theme-notice), direction: 'up', size: 5px)
		left: 15%
		transition: opacity 200ms

		&.-hide
			opacity: 0

.-poll-option
	display: flex

	.form-group
		flex-grow: 1
		margin-bottom: ($font-size-base / 2)

.-poll-option-remove
	width: 40px
	line-height: $input-height-base
	text-align: center

.-poll-duration
	.form-group
		margin-bottom: 0

.-linked-accounts
	.form-group
		margin-bottom: 0

.-linked-account
	display: flex
	align-items: center
	margin-top: 10px

.-linked-account-icon
	flex: none
	margin-right: 10px

.-linked-account-label
	flex: auto
	margin-right: 10px

.-linked-account-toggle
	flex: none

.-content-targets
	margin: 10px 0

.-content-targets-placeholder
	margin: 10px 0 14px

.-content-target-placeholder
	change-bg('bg-subtle')
	rounded-corners()
	width: 138px

.-author-avatar
	width: $input-height-base
	margin-right: 8px

@media $media-xs
	.-controls
		display: flex
		flex-direction: column

	.-controls-attachments
		display: flex
		justify-content: center
		margin-bottom: $line-height-computed
		padding: 10px 0
		border-top: $border-width-base solid var(--theme-bg-subtle)
		border-bottom: $border-width-base solid var(--theme-bg-subtle)

		> :not(:first-child)
			margin-left: 10px !important

	.-controls-submit
		display: flex

	.-controls-submit-button
		flex: 1 0
		margin-right: 10px
		margin-left: 10px

		&:first-of-type
			margin-left: 0

		&:last-of-type
			margin-right: 0

@media $media-sm-up
	.-controls
		display: flex
		flex-direction: row

	.-controls-attachments
		flex: auto

		> *:not(:first-child)
			margin-left: 4px !important

	.-controls-submit
		flex: none

	.-controls-submit-button
		display: inline-block

.-overlay-text
	&
	> *
	.-overlay-text-affected
		text-shadow: black 1px 1px 4px
		color: white

.-text-white
	color: white !important

.-overlay-box
	elevate-1()

.-popover-container
	max-width: 300px
</style>
