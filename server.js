const fs = require('fs');
const path = require('path');
const express = require('express');
const { renderToString } = require('vue/server-renderer');

const projectRoot = path.resolve(__dirname);
const buildDir = path.join(projectRoot, 'build');
const serverBuildPath = path.join(buildDir, 'server');
const webBuildPath = path.join(buildDir, 'web');

const indexHtmlTemplate = fs.readFileSync(path.join(webBuildPath, 'index.html'), 'utf-8');
const ssrManifest = require(path.join(webBuildPath, 'ssr-manifest.json'));
const createApp = require(path.join(serverBuildPath, 'server.js')).default;

const server = express();

// Only needed in dev builds, in prod everything would be served from cdn.
server.use(
	express.static(webBuildPath, {
		// maxAge: 0,
		// fallthrough: true,
		index: false,
	})
);

// TODO: refactor this into somewhere else.
function renderPreloadLinks(modules, manifest) {
	let links = '';
	const seen = new Set();
	modules.forEach(id => {
		const files = manifest[id];
		if (files) {
			files.forEach(file => {
				if (!seen.has(file)) {
					seen.add(file);
					const filename = path.basename(file);
					if (manifest[filename]) {
						for (const depFile of manifest[filename]) {
							links += renderPreloadLink(depFile);
							seen.add(depFile);
						}
					}
					links += renderPreloadLink(file);
				}
			});
		}
	});
	return links;
}

function renderPreloadLink(file) {
	if (file.endsWith('.js')) {
		return `<link rel="modulepreload" crossorigin href="${file}">`;
	} else if (file.endsWith('.css')) {
		return `<link rel="stylesheet" href="${file}">`;
	} else if (file.endsWith('.woff')) {
		return ` <link rel="preload" href="${file}" as="font" type="font/woff" crossorigin>`;
	} else if (file.endsWith('.woff2')) {
		return ` <link rel="preload" href="${file}" as="font" type="font/woff2" crossorigin>`;
	} else if (file.endsWith('.gif')) {
		return ` <link rel="preload" href="${file}" as="image" type="image/gif">`;
	} else if (file.endsWith('.jpg') || file.endsWith('.jpeg')) {
		return ` <link rel="preload" href="${file}" as="image" type="image/jpeg">`;
	} else if (file.endsWith('.png')) {
		return ` <link rel="preload" href="${file}" as="image" type="image/png">`;
	} else {
		// TODO
		return '';
	}
}

server.use(async (req, res) => {
	try {
		const context = {
			url: req.url,
			ua: req.headers['user-agent'],
			accept: req.headers['accept'] || '',
		};

		console.log(context);

		const app = await createApp(context);

		// passing SSR context object which will be available via useSSRContext()
		// @vitejs/plugin-vue injects code into a component's setup() that registers
		// itself on renderCtx.modules. After the render, renderCtx.modules would contain all the
		// components that have been instantiated during this render call.
		const renderCtx = {};
		const appHtml = await renderToString(app, renderCtx);

		// console.log(renderCtx.modules);

		// the SSR manifest generated by Vite contains module -> chunk/asset mapping
		// which we can then use to determine what files need to be preloaded for this
		// request.
		const preloadLinks = renderPreloadLinks(renderCtx.modules, ssrManifest);

		const html = indexHtmlTemplate
			.replace(`<!--ssr-preload-links-->`, preloadLinks)
			.replace(`<!--ssr-outlet-->`, appHtml);

		res.status(200)
			.set({ 'Content-Type': 'text/html' })
			.end(html, () => {
				console.log('response ended');
			});
		console.log('request ending');
	} catch (e) {
		console.log(e.stack);
		res.status(500).end(e.stack);
	}
});

const port = 3501;
server.listen(port, () => {
	console.log(`server started at localhost:${port}`);
});
